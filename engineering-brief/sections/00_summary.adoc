== Executive Summary

=== The Problem

The ChRIS platform consists of a core backend called CUBE that provides API services to clients. While this represents a relatively standard design pattern, closer examination reveals a critical architectural impedance mismatch between CUBE's declarative Collection+JSON resource model and the procedural workflow requirements of clients (discussed in detail in Section 4.1). The mismatch is fundamental: CUBE's backend model is internally focused and agnostic to specific client needs. CUBE's hypermedia API excels at representing computational entities and their relationships, but clients must independently implement complex orchestration logic to translate user intentions into multi-step REST operations.

The original intent of CUBE's hypermedia API was to encourage a multitude of clients. Since hypermedia relies on semantic relationships between resources, clients could assemble these relationships into any problem domain. In reality, the opposite has occurred: the client ecosystem has stagnated. The ChRIS_UI [6] remains the primary viable client. The Python client library [21] experienced extended stagnation from 2022-2024. The Rust client [7] stagnated after September 2024 despite 27 releases and 420 commits, never achieving feature parity with the UI. When chrs stagnated, downstream tools dependent on its functionality also halted: CLI experiments like ChILI [6] showed promise as an interactive Node.js interface but development stopped in February 2025, and utility tools like pipeline2cube [20] designed to register workflows and plugins have been inactive since January 2023. This pattern demonstrates that orchestration complexity creates a barrier preventing client ecosystem growth and that stagnation in one client library cascades to dependent tools.

Additional symptoms include *UI architectural degradation* (presentation conflated with orchestration, violating separation of concerns [16]), and *maintenance complexity* (scattered orchestration increases cognitive load, representing compounding technical debt [12]). These symptoms align with Lehman's Laws [13]: systems failing to reduce coupling experience declining adaptability.

=== The Recommendation

This plan proposes introducing an *Intent-Action Service (IAS)*, an external orchestration layer translating high-level procedural intents into coordinated CUBE operations. The IAS provides task-oriented APIs exposing domain operations (download datasets, execute pipelines) rather than infrastructure primitives (feeds, plugins, files). This architecture: (1) *preserves* CUBE's Collection+JSON foundation while adding procedural interpretation; (2) *enables* client ecosystem revival through centralized orchestration; (3) *liberates* the UI to pure presentation layer; (4) *supports* incremental validation (one intent at a time) allowing empirical evaluation before full commitment.

The IAS follows Backend-for-Frontend patterns [15] and addresses the architectural incompleteness limiting hypermedia adoption [3]: declarative resource models alone cannot satisfy procedural client requirements.

=== Constraints and Context

ChRIS/CUBE serves as a *general-purpose distributed compute platform* for containerized workflow orchestration across federated infrastructure (not domain-specific to medical imaging but applicable to physical oceanography, climate research, genomics, or any field requiring computational workflow management). This generality is encoded in CUBE's Collection+JSON hypermedia approach, which models workflows as resources and relationships rather than hardcoded procedures.

ChRIS is a production system with institutional dependencies and accumulated domain knowledge in CUBE's API. Complete Collection+JSON replacement would require massive re-engineering with unclear benefits and no incremental migration path. The IAS works *with* existing infrastructure, adding procedural interpretation capability without discarding the declarative foundation that supports general-purpose applicability. This approach accepts operational complexity (additional service deployment) in exchange for architectural clarity, evolutionary independence, and ecosystem enablement, a trade-off characteristic of well-designed distributed systems [16; 4].
