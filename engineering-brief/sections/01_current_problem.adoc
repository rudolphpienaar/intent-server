== Current Architecture and Its Limitations

The ChRIS ecosystem comprises CUBE, a Collection+JSON backend [1], and ChRIS-UI, a React web interface. CUBE models computational workflows as declarative resources connected through hypermedia links, offering architectural flexibility at the cost of client complexity. This creates a fundamental impedance mismatch: users think procedurally ("download this dataset", "run this pipeline") while CUBE requires declarative resource manipulation ("create feed, attach plugin instance, configure parameters").

.Current ChRIS Architecture (Status Quo)
image::fig01_current_architecture_v2.png[Current Architecture,width=100%]

=== The Orchestration Problem

Every non-trivial operation requires clients to perform multiple steps: query the hypermedia graph to discover resources, construct multi-step REST sequences, manage asynchronous execution and error recovery, and extract results from response payloads. Each client reimplements this orchestration logic independently, producing fragmentation, code duplication, and inconsistent behavior across the ecosystem [10]. This cognitive burden has deterred external development, leaving ChRIS-UI as the sole functional client.

The UI absorbed this orchestration responsibility by necessity, creating architectural degradation. Procedural helper functions encode workflow knowledge within presentation components. State management tracks asynchronous execution alongside UI state. Business logic entangles with presentation concerns. This violates fundamental layered architecture principles [16]: presentation tiers should consume stable service interfaces, not implement backend coordination logic. The consequences are predictable: code becomes difficult to test (presentation and orchestration cannot be isolated), difficult to maintain (workflow changes require UI modifications), and difficult to evolve (developers must understand both React patterns and CUBE orchestration semantics).

This pattern of declarative APIs creating orchestration burdens is well-documented in distributed systems literature. The Backend-for-Frontend pattern [15] emerged precisely to address this problem: when general-purpose APIs cannot efficiently serve diverse client needs, an intermediate orchestration layer provides task-oriented abstractions. API Composition patterns [17] formalize the need to aggregate operations across microservices. While these solutions are established for microservices and traditional REST APIs, they remain largely unapplied in the HATEOAS space. The Intent-Action Service represents a logical extension of these proven patterns to hypermedia-driven systems, addressing an architectural gap that empirical studies show affects 95%+ of REST APIs attempting Level 3 maturity [18].

The workflow-hypermedia tension has been recognized in scientific computing. Balis [2] proposed "Hypermedia Workflow" for data-driven scientific workflows, applying REST principles by making workflows themselves hypermedia resources where execution proceeds through HATEOAS state transitions. This approach is conceptually elegant but inverted from the IAS solution: Balis assumes clients can navigate workflow state via hypermedia, while the IAS observes that clients require task-oriented endpoints that encapsulate navigation logic. Balis integrates workflow into the hypermedia model; the IAS separates orchestration into a dedicated service. Both recognize the workflow-hypermedia tension but differ in resolution strategy. The IAS preference for external orchestration reflects pragmatic assessment: making workflows hypermedia-native requires sophisticated client logic, while providing task-oriented intent endpoints enables simpler clients.

From a system evolution perspective, this architecture has reached a local maximum [13]. The UI cannot evolve into a pure presentation layer without extracting orchestration; external clients cannot viably develop without access to that logic. Python client experiments (2019-2021) never achieved feature parity; CLI tools remain proof-of-concept. The root cause is architectural: pure hypermedia provides declarative expressiveness but lacks procedural interpretation.
