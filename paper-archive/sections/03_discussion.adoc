== Discussion

The preceding analysis examined three architectural pathways for addressing the procedural-declarative impedance mismatch in the ChRIS ecosystem: maintaining the status quo with orchestration embedded in the UI (Section 2.1), internalizing intent logic within CUBE itself (Section 2.3), and deploying an external Intent-Action Service (Section 2.4). Each represents a distinct set of trade-offs between architectural purity, operational complexity, and evolutionary adaptability. This section evaluates these alternatives comparatively, situates the IAS proposal within broader patterns in distributed systems design, addresses anticipated objections, and explores implications for the ChRIS ecosystem.

=== Comparative Analysis

The three architectural paths differ fundamentally in where they locate orchestration responsibility and how they balance competing concerns. The following analysis evaluates each approach across five critical dimensions: architectural purity, evolutionary velocity, operational complexity, security model, and client ecosystem enablement.

.Comparative evaluation of architectural approaches
[cols="2,3,3,3",options="header"]
|===
|Dimension |Status Quo (2.1) |Embedded in CUBE (2.3) |External IAS (2.4)

|**Architectural Purity**
|Violates separation: UI handles orchestration and presentation
|Compromises CUBE's declarative model by adding procedural layer
|Preserves CUBE's declarative purity; clean separation of concerns

|**Evolutionary Velocity**
|Slow: UI changes require understanding both presentation and orchestration logic
|Constrained: procedural evolution tied to CUBE release cycles
|Fast: IAS evolves independently; rapid iteration on workflows

|**Operational Complexity**
|Low: single deployment (UI+CUBE), but high maintenance burden
|Medium: orchestration within existing CUBE boundary; no new services
|High: three services (UI, IAS, CUBE + authCore), but modular and observable

|**Security Model**
|Distributed credentials across client implementations; inconsistent enforcement
|Unified within CUBE; strong consistency but requires CUBE modification
|Credential brokering via authCore; defense-in-depth without distributing secrets

|**Client Ecosystem**
|Stagnant: each client rebuilds orchestration; fragmentation and abandonment
|Improved but limited: clients use embedded logic but remain CUBE-version coupled
|Enabled: shared IAS across all clients; encourages ecosystem diversity
|===

The comparative evaluation reveals a clear pattern. The status quo fails on nearly every dimension except operational simplicity—and even that advantage is illusory, as maintenance complexity has effectively stalled development. The embedded approach improves several dimensions but introduces fundamental coupling between fast-changing procedural logic and slow-evolving declarative semantics. The external IAS accepts higher operational complexity in exchange for architectural clarity, evolutionary independence, and cleaner separation of concerns.

The operational complexity argument deserves particular scrutiny. Deploying three services instead of two undeniably increases infrastructure demands: additional containers, monitoring endpoints, network paths, and failure modes. However, this complexity is *essential* rather than *accidental* in Brooks's terminology [13]. The orchestration function exists regardless of where it resides. Embedding it within the UI or CUBE does not eliminate complexity; it merely obscures it within components responsible for other concerns. Externalizing orchestration into the IAS makes this complexity explicit, observable, and manageable. The trade-off is not between complexity and simplicity, but between hidden entanglement and transparent modularity.

From a system evolution perspective, the external IAS aligns with Lehman's observation that successful systems must actively reduce coupling to avoid architectural decay [11]. By separating procedural workflows from declarative resources, the IAS enables independent evolution: CUBE can refine its semantic model without coordinating with workflow authors, while the IAS can add new intent handlers without CUBE modifications. This evolutionary independence becomes increasingly valuable as system scope expands and contributor diversity grows.

=== The Missing Middle Layer

The broader context of hypermedia API adoption provides instructive perspective. As documented in Section 1, HATEOAS-driven designs—including Collection+JSON, JSON-LD, and HAL—saw minimal real-world uptake despite strong conceptual foundations [5][6]. Most practitioners abandoned hypermedia constraints in favor of simpler approaches: OpenAPI for documentation, GraphQL for flexible querying, gRPC for performance. This shift has often been characterized as pragmatism defeating purism, as developers chose practicality over REST's theoretical completeness.

However, this narrative misses a critical insight: hypermedia systems did not fail because they were conceptually wrong, but because they were *architecturally incomplete*. Hypermedia excels at describing what exists and how entities relate—the vocabulary of resources, relationships, and state transitions. What hypermedia alone cannot provide is *procedural execution*: the interpretation of client goals and orchestration of multi-step operations. Clients confronted with pure hypermedia APIs must implement this layer themselves, repeatedly and inconsistently. The result was the pragmatic abandonment documented in API maturity studies [8][7].

The Intent-Action Service completes what hypermedia architectures always lacked: an *intent interpretation layer* that bridges declarative resource models and procedural client needs. This is not a departure from hypermedia principles but their fulfillment. CUBE's Collection+JSON substrate continues to provide semantic richness, discoverability, and extensibility. The IAS adds executable workflows and task-oriented operations. Together, they deliver both declarative completeness and procedural accessibility—the combination that standalone hypermedia could not achieve.

An instructive parallel exists in database systems. SQL provides declarative query semantics: users specify *what* data they want, not *how* to retrieve it. Yet databases also provide stored procedures, triggers, and user-defined functions—procedural constructs that complement the declarative model. Nobody argues that stored procedures invalidate relational theory; they are recognized as essential for certain operations that declarative queries cannot express efficiently. The coexistence of declarative and procedural layers in databases is not a compromise but a design strength [35].

The IAS-CUBE relationship follows this pattern. CUBE provides the declarative substrate—the "schema" of feeds, plugins, and files. The IAS provides procedural operations—the "stored procedures" that orchestrate complex workflows. Clients can query CUBE directly for exploration and discovery, or invoke IAS intents for execution and orchestration. Both interfaces serve legitimate purposes; both are necessary. The failure of hypermedia APIs was not inevitable—it resulted from the absence of this complementary procedural layer.

This observation has implications beyond ChRIS. Many domain-specific platforms face similar challenges: rich semantic models that accurately represent domain entities but lack accessible operational interfaces. Scientific workflow systems, federated data platforms, and institutional computing infrastructure all struggle with the same tension between semantic precision and operational usability. The IAS pattern—declarative substrate plus procedural interpretation layer—offers a general architectural solution applicable across domains.

=== Addressing Counterarguments

Several objections to the external IAS approach merit direct examination.

==== "Just abandon Collection+JSON and modernize CUBE's API"

The most common reaction to the challenges documented in Section 2.1 is to replace Collection+JSON entirely with a conventional REST API design, GraphQL endpoint, or gRPC interface. This would immediately simplify client construction and align ChRIS with dominant industry patterns. The appeal is obvious: eliminate the source of complexity rather than accommodate it.

However, this approach fundamentally misunderstands what CUBE provides. Collection+JSON is not merely a serialization format or API style—it encodes the *semantic model* of the ChRIS platform. The hypermedia structure represents feeds as computational lineages, plugins as reusable processing components, and files as provenance-tracked artifacts. These relationships are first-class elements of the model, not implementation details. CUBE's API exposes this model directly, enabling clients to reason about computational workflows at a semantic level.

Replacing Collection+JSON would require not just API redesign but reconceptualization of how ChRIS represents computation. Every component that depends on semantic traversal—workflow reconstruction, provenance tracking, resource discovery—would need reimplementation. The institutional knowledge embedded in CUBE's data model, accumulated through years of medical imaging workflow development, would be discarded. The cost would be enormous, the risk significant, and the benefit uncertain: clients would gain a more conventional API but lose semantic expressiveness.

More fundamentally, abandoning Collection+JSON solves the wrong problem. The difficulty clients face is not CUBE's declarative model per se, but the absence of a procedural interface *complementing* that model. The IAS provides exactly this: a task-oriented API that simplifies common operations while preserving CUBE's semantic foundation. Clients can use IAS intents for execution and CUBE's Collection+JSON API for exploration, gaining the benefits of both paradigms without sacrificing either.

The parallel to SQL is again instructive. When developers find SQL's declarative queries insufficient for certain operations, the solution is not to abandon relational databases but to add procedural capabilities through stored procedures or application logic. The declarative foundation remains valuable; it simply needs procedural augmentation. The same logic applies to CUBE: Collection+JSON remains the right model for representing computational entities and relationships. It needs an intent interpretation layer, not replacement.

==== "This adds too much complexity"

The external IAS introduces additional infrastructure: another service to deploy, monitor, secure, and maintain. In an era emphasizing operational simplicity and minimizing dependencies, adding services appears counterproductive. Why not consolidate functionality rather than distributing it further?

This objection conflates *visible* complexity with *total* complexity. The orchestration functionality that the IAS provides already exists—it is currently embedded within the ChRIS UI as scattered helper functions, callback chains, and ad-hoc state management. This complexity is no less real for being hidden; it is merely harder to observe, test, and maintain. Developers modifying UI components must understand both presentation logic and the orchestration semantics interleaved within it. New contributors face steep learning curves as they untangle these concerns.

Externalizing orchestration into the IAS does not create complexity—it relocates and structures it. The total complexity of the system remains roughly constant (and arguably decreases due to eliminating duplication), but it becomes *managed* rather than *entangled*. The IAS can be tested independently, scaled independently, and reasoned about independently. Its API surface provides a clear contract. Observability tooling can instrument request flows and identify bottlenecks. This is the essence of modular design: accepting explicit service boundaries in exchange for comprehensibility and evolvability [14].

Furthermore, the operational complexity of running an additional service must be weighed against the development complexity of maintaining entangled codebases. Containerized deployments with orchestration platforms (Kubernetes, Docker Swarm) have substantially reduced the marginal cost of additional services. A well-designed microservice with clear boundaries is often easier to operate than a monolithic application with hidden internal complexity. The IAS fits this pattern: it is a focused service with well-defined responsibilities, easier to reason about than the alternative of procedural logic scattered across multiple UI components.

The complexity argument also overlooks trajectory. The status quo appears simple because it involves fewer deployed services, but this simplicity has produced architectural stagnation. The development velocity has slowed to the point where meaningful evolution is difficult. Adding the IAS increases operational overhead in the short term but removes the structural impediments to long-term growth. This trade-off—immediate operational cost for sustained evolutionary capacity—is characteristic of investments in architectural health [12].

==== "Keep it simple—just refactor the UI"

A more moderate objection accepts that orchestration logic should be better structured but argues for refactoring it within the UI rather than extracting it entirely. Consolidate the scattered intent translation code into a coherent module, improve internal interfaces, and document the patterns. This preserves the two-service architecture (UI and CUBE) while addressing the maintainability concerns identified in Section 2.1.

This approach represents an improvement over the current state but fails to address the fundamental problems. First, it does nothing for client ecosystem diversity. Orchestration logic refactored within the ChRIS UI remains inaccessible to Python clients, CLI tools, automation scripts, or other interfaces. Each must still reimplement the same orchestration patterns independently. The fragmentation and duplication that stalled client development would persist.

Second, it perpetuates the category error of housing orchestration within a presentation tier. The ChRIS UI is a React application designed for browser-based user interaction. Orchestration logic—stateful workflows, retry logic, error handling, progress tracking—belongs in a backend service where it can be managed, monitored, and secured appropriately. Keeping it in the UI conflates concerns and limits operational capabilities. For example, long-running workflows cannot outlive a browser session; error recovery depends on client-side state management; observability requires instrumenting JavaScript execution.

Third, refactoring within the UI provides no path toward agentic integration. LLM-driven agents cannot easily consume a JavaScript library embedded in a web application. They require server-side APIs with clear contracts and documentation. The IAS provides this naturally; a refactored UI module does not.

The refactoring approach treats symptoms rather than causes. It improves code organization within the UI but leaves the architectural mismatch unresolved. The orchestration concern remains in the wrong architectural layer, limiting both the system's capabilities and its evolution. A proper solution requires extracting orchestration into an independent service—exactly what the IAS provides.

=== Implications for ChRIS Evolution

The introduction of an external IAS would have cascading effects throughout the ChRIS ecosystem, enabling developments that the current architecture inhibits.

==== Client Ecosystem Revival

The stagnation of ChRIS client development, documented in Section 2.1, results directly from the lack of a shared orchestration layer. Every client implementation must map between user intentions and CUBE's Collection+JSON primitives independently. This burden has proven sufficient to discourage most development efforts: beyond the ChRIS UI, no fully functional clients exist despite years of interest from the community.

An operational IAS immediately changes this calculus. Client developers in any language can invoke intent endpoints to perform complex workflows without reimplementing orchestration logic. A Python researcher can write:

[source,python]
----
response = ias_client.anonymize_and_convert(
    patient_id="12345",
    modality="MRI",
    output_format="nifti"
)
----

This operation abstracts away feed creation, plugin chaining, status monitoring, and error handling. The developer focuses on domain logic—*what* to analyze—rather than CUBE semantics—*how* to orchestrate resources. The same applies to JavaScript, Rust, Go, or any language with HTTP client capabilities. The IAS democratizes access to ChRIS functionality.

This democratization has multiplicative effects. Plugin developers, who currently interact with ChRIS primarily through documentation and JSON schemas, could access intent-level APIs that simplify plugin testing and integration. Institutional workflows, often implemented as brittle scripts directly calling CUBE endpoints, could use stable IAS interfaces less susceptible to breakage. Educational contexts—teaching medical imaging analysis or computational workflows—could leverage simplified APIs that expose domain concepts rather than infrastructure details.

The client ecosystem effects extend to contribution patterns. External developers currently face high barriers to ChRIS contribution: understanding Collection+JSON semantics, navigating CUBE's resource graph, implementing multi-step orchestration patterns. With the IAS, contributions can focus on intent implementations: adding new workflow types, improving existing orchestrations, or exposing new plugin capabilities. The cognitive barrier drops substantially, encouraging broader ecosystem participation.

==== UI Liberation

For the ChRIS UI specifically, the IAS represents liberation from dual responsibility. Currently, the UI must provide both visual presentation of ChRIS entities and programmatic orchestration of CUBE operations. These concerns have become increasingly entangled as documented in Section 2.1, creating maintenance burden and slowing development velocity.

With an operational IAS, the ChRIS UI can focus exclusively on what user interfaces do best: rendering information, responding to interaction, and providing intuitive workflows. React components call IAS endpoints for operations and CUBE's Collection+JSON API for queries. Orchestration logic—feed creation sequences, plugin parameter validation, workflow state management—resides in the IAS where it belongs. The UI becomes *thin* again, focused on presentation concerns.

This separation accelerates UI development in several ways. First, UI developers can iterate on visual design and user experience without navigating orchestration logic. Second, testing simplifies: UI components test presentation and interaction patterns; intent orchestration tests reside in the IAS. Third, the UI becomes more maintainable: changes to workflow orchestration do not require UI modifications and vice versa. These benefits compound over time as the system evolves.

The separation also enables UI diversity. With orchestration externalized to the IAS, alternative UIs become feasible: lightweight web interfaces for specific workflows, mobile applications, command-line interactive tools, or institutional portals customized for specific environments. Each can leverage the same IAS backend while providing presentation appropriate to its context. The current architecture, with orchestration embedded in the primary UI, makes such diversity impractical.

==== Research Accessibility

From the perspective of domain scientists—radiologists, neuroscientists, clinical researchers—the IAS represents a substantial reduction in conceptual overhead. Currently, interacting with ChRIS programmatically requires understanding its architectural model: feeds as computational roots, plugins as directed acyclic graph nodes, files as provenance artifacts. While these abstractions are elegant from a systems perspective, they impose cognitive burden on researchers whose expertise lies in medical imaging, not distributed computing architecture.

Intent-level APIs map more naturally to domain thinking. A researcher does not conceptualize analysis as "creating a feed with a root node, attaching a plugin instance, configuring parameters, and monitoring execution." The researcher thinks: "anonymize this dataset and run FreeSurfer on the T1-weighted images." The IAS enables this directness. Intent endpoints expose domain operations—anonymize, segment, register, quantify—rather than infrastructure primitives.

This accessibility has implications for computational reproducibility and scientific workflow management. Researchers can encode analysis pipelines as sequences of intent calls, producing self-documenting scripts that express scientific logic clearly. Journals and institutions increasingly require computational methods to be reproducible; intent-based scripts are more comprehensible to reviewers than low-level CUBE orchestration code. The IAS thus contributes to open science goals by lowering the barrier to transparent, reproducible computational workflows.

Furthermore, the intent abstraction enables progressive disclosure of complexity. Researchers can begin with high-level intents for common operations, then gradually learn lower-level CUBE interactions as their needs become more sophisticated. This layered accessibility—simple interfaces for common cases, powerful primitives for advanced use—is characteristic of well-designed systems [36]. The IAS provides the simple layer; CUBE's Collection+JSON API provides the powerful primitives. Together, they serve users across the expertise spectrum.

=== Future Direction: Potential LLM Integration

While the IAS proposal primarily addresses current client ecosystem challenges, the architecture may offer secondary benefits for AI-augmented computing. Task-oriented intent endpoints with clear semantic descriptions are potentially more accessible to language models than hypermedia graph traversal [32]. Where direct CUBE usage requires multi-step orchestration, IAS intents encapsulate workflows as atomic operations. Whether this theoretical advantage materializes in practice depends on several uncertain factors: LLM capability evolution, API design quality, natural language to intent mapping reliability, and user acceptance of AI-mediated scientific computing.

We acknowledge this possibility but emphasize three important caveats. First, LLM integration is not a validation criterion for the IAS architecture—the proposal stands or falls on its ability to address documented client development challenges. Second, agentic computing patterns in scientific domains remain largely speculative; production adoption faces significant hurdles around reliability, auditability, and institutional acceptance. Third, any future LLM integration would require careful security design to maintain proper authentication, authorization, and audit trails regardless of whether operations are invoked by human developers or AI agents.

The IAS architecture neither assumes nor requires LLM integration. If such capabilities mature and prove valuable, the task-oriented API design may accommodate them more readily than direct hypermedia access. If they do not, the architecture's value rests on the core benefits analyzed throughout this paper: ecosystem enablement, UI simplification, and separation of concerns.

=== Limitations and Future Work

The external IAS architecture, while offering substantial advantages, introduces challenges and open questions that warrant examination.

==== Implementation Challenges

Defining and governing the intent vocabulary presents ongoing challenges. Unlike CUBE's resource model, which reflects relatively stable domain entities (feeds, plugins, files), the intent space is open-ended. New workflows emerge continuously as researchers develop novel analyses. The IAS must evolve its intent catalog accordingly, balancing stability for existing clients against extensibility for new capabilities.

Several governance approaches merit consideration. A formal intent schema with versioning would provide stability guarantees and enable client code generation, but might slow evolution. A plugin-based intent registry where developers contribute intent handlers would maximize extensibility but could fragment the intent space. Hybrid approaches—a curated core set of intents plus an extension mechanism for domain-specific workflows—might balance these concerns. Regardless of approach, establishing conventions for intent naming, parameter schemas, and semantic documentation will be critical.

API versioning and backward compatibility require careful management. As intent implementations evolve—supporting new parameters, changing orchestration logic, or improving error handling—the IAS must maintain compatibility with existing clients or provide clear migration paths. Standard API versioning strategies apply (URL versioning, header-based versioning, content negotiation), but determining the right granularity for version boundaries remains context-dependent. Overly coarse versioning hinders evolution; overly fine versioning burdens clients with constant adaptation.

Performance implications deserve empirical evaluation. The IAS introduces an additional network hop in the request path: client → IAS → CUBE rather than client → CUBE directly. For high-frequency, low-latency operations, this overhead may be significant. Caching strategies, request batching, and connection pooling can mitigate latency, but fundamental limits exist. Performance-critical clients may need the option to bypass the IAS and interact with CUBE directly for specific operations. Establishing clear guidance on when to use intent APIs versus direct CUBE access will inform client design.

Observability across three service boundaries (UI/client, IAS, CUBE, plus authCore) increases operational complexity. Distributed tracing becomes essential to understand request flows and diagnose failures. Establishing consistent trace context propagation, correlating logs across services, and providing unified dashboards for operational visibility will require investment in observability infrastructure. Tools like OpenTelemetry provide standardized approaches, but integration requires deliberate engineering effort.

==== Open Questions

Several architectural and design questions merit further exploration as the IAS concept matures.

*Multi-institutional federation:* The current design assumes a single IAS instance serving a single CUBE deployment. However, ChRIS envisions federated operation where multiple institutions run independent CUBE instances and share workflows. Should each institution operate its own IAS, or should a federated IAS coordinate across multiple CUBEs? The former maximizes institutional autonomy but may fragment the intent vocabulary; the latter simplifies client development but introduces complex coordination requirements. Hybrid approaches—local IAS instances with shared intent schemas—might balance these concerns.

*Workflow language integration:* Scientific workflow systems like Common Workflow Language (CWL), Nextflow, and Snakemake provide standardized approaches to expressing computational pipelines. How should the IAS relate to these systems? One approach treats workflow languages as intent sources: a CWL document describes a workflow, and the IAS translates it into CUBE operations. Another approach exposes IAS intents as workflow primitives that CWL authors can compose. Exploring these integration patterns could position ChRIS within broader workflow ecosystem developments.

*Intent composition and meta-intents:* Current IAS design assumes atomic intents—single operations like "anonymize" or "segment." However, researchers often need composite workflows: "anonymize these datasets, run quality control, and if QC passes, execute these three analysis pipelines in parallel." Should the IAS support intent composition, allowing clients to express complex workflows as compositions of simpler intents? If so, what composition semantics are appropriate—sequential, parallel, conditional, iterative? Alternatively, should complex workflows remain client-side orchestration concerns, with the IAS providing only atomic operations? The design choice significantly impacts both IAS complexity and client capabilities.

*Intent discoverability:* How do clients discover available intents and their parameters? CUBE's Collection+JSON API provides hypermedia links for resource discoverability; the IAS needs analogous mechanisms for intent discoverability. OpenAPI specifications provide machine-readable schemas, but they lack semantic richness. Ontology-based approaches could provide richer semantics but require standardized vocabularies. Investigating discoverability mechanisms that balance machine-readability with human comprehensibility would improve developer experience.

*Economic and resource models:* In multi-tenant or cloud-hosted ChRIS deployments, the IAS may need to mediate resource allocation and billing. Complex intents consume varying computational resources; institutional policies may impose quotas or cost controls. Should the IAS provide resource estimation before execution? Should it enforce quotas directly or delegate to CUBE? How should billing attribution work when multiple services contribute to cost? These questions become practical concerns as ChRIS adoption expands beyond single-institution deployments.

==== Research Directions

Beyond immediate implementation concerns, the IAS architecture opens several research directions in distributed systems and human-computer interaction.

*Intent inference and learning:* Rather than requiring users to specify intents explicitly, could systems infer intent from interaction patterns? Analyzing sequences of CUBE operations performed by researchers might reveal common patterns amenable to intent abstraction. Machine learning approaches could cluster operation sequences and suggest new intent candidates for formalization. This data-driven intent discovery could complement expert-driven intent design.

*Natural language to intent translation:* While Section 3.5 discussed LLM-based intent invocation, deeper questions remain about grounding natural language expressions in formal intent representations. How can systems ensure that LLM-generated intent calls accurately reflect user goals? What verification and confirmation mechanisms prevent misinterpretation? Can conversational interfaces iteratively refine intent parameters through dialogue? Research in natural language interfaces for scientific computing could leverage the IAS as a concrete substrate for experimentation.

*Intent provenance and reproducibility:* Scientific reproducibility requires capturing not just computational steps but the intentions behind them. An intent-based provenance model could record *why* operations were performed—"anonymization for regulatory compliance" versus "anonymization for public dataset release"—not just the technical parameters. Exploring how intent semantics enhance computational provenance could advance reproducible science practices.

*Cross-domain intent transfer:* If the IAS pattern proves successful in medical imaging via ChRIS, can intent vocabularies transfer to other scientific domains? Are there common intent patterns—data acquisition, quality control, transformation, analysis, visualization—that appear across domains? Standardizing cross-domain intent ontologies could enable workflow portability and accelerate adoption of computational methods across fields.

=== Validation Criteria

To determine whether the IAS architecture succeeds in practice, we propose measurable validation criteria that operationalize the research questions presented in Section 1. These criteria establish concrete thresholds for success and failure, enabling objective evaluation once implementation proceeds.

==== Success Indicators

*Client Code Complexity:* Intent-based implementations should demonstrate measurably lower complexity than equivalent direct CUBE implementations. We will measure:

- Lines of code (LOC) for representative workflows (target: 40–60% reduction)
- Cyclomatic complexity of orchestration logic (target: <5 per operation)
- Number of API calls required for common tasks (target: 1–3 intent calls vs. 8–15 CUBE calls)

*Developer Velocity:* Time to implement common workflows should decrease significantly:

- Time-to-first-success for new developers (target: <2 hours for basic workflows)
- Implementation time for representative tasks (target: 30–50% reduction)
- Onboarding documentation length and complexity (target: readable in <30 minutes)

*Performance Overhead:* The additional IAS layer must not introduce unacceptable latency:

- End-to-end latency overhead (acceptable: <200ms per intent call)
- Throughput for high-frequency operations (acceptable: >100 requests/second)
- Resource consumption (acceptable: <20% additional memory/CPU vs. direct CUBE calls)

*Developer Experience:* Qualitative assessment through surveys and interviews should show improvement:

- System Usability Scale (SUS) scores (target: >70, indicating "good" usability)
- Net Promoter Score for IAS adoption (target: >0, indicating more promoters than detractors)
- Qualitative feedback indicating reduced cognitive load and clearer mental models

*Ecosystem Growth:* Client diversity should increase following IAS deployment:

- Number of active client implementations (target: 3+ beyond ChRIS UI within 12 months)
- Contributor diversity (target: contributions from 5+ external developers)
- Intent vocabulary expansion (target: 20+ production-ready intents within 18 months)

*Independent Evolution:* IAS and CUBE should demonstrate version independence:

- CUBE minor version updates should not require IAS changes (target: 80% compatibility)
- IAS intent additions should not require CUBE modifications (target: 100% independence)
- Client code should remain functional across IAS updates (target: zero breaking changes in minor versions)

==== Failure Indicators

Equally important are criteria that would indicate the IAS approach is not succeeding:

*Complexity Migration:* If the IAS merely relocates complexity rather than reducing it:

- IAS intent implementations exceed 500 LOC per intent (suggesting orchestration is as complex as client-side alternatives)
- Clients bypass IAS for most operations, preferring direct CUBE access (suggesting IAS does not provide value)
- Intent composition becomes as complex as direct CUBE orchestration (suggesting abstraction failed)

*Dual API Burden:* If maintaining both APIs proves unsustainable:

- Developer resources for API maintenance exceed 2 FTE (suggesting overhead outweighs benefits)
- Intent-CUBE semantic drift requires frequent reconciliation (suggesting coupling remains high)
- Documentation and support burden doubles without corresponding ecosystem growth

*Performance Degradation:* If latency overhead proves unacceptable:

- Average intent call latency exceeds 500ms (unacceptable for interactive workflows)
- Throughput drops below 20 requests/second (insufficient for production workloads)
- Resource consumption increases by >50% (economically unsustainable)

*Adoption Resistance:* If developers actively avoid the IAS:

- SUS scores below 50 (indicating poor usability)
- Net Promoter Score below -20 (indicating strong detractor sentiment)
- Client implementations continue bypassing IAS after 12 months (market rejection)

==== Commitment to Transparent Reporting

We commit to publishing evaluation results regardless of outcome. If validation indicates the IAS approach does not deliver expected benefits, documenting what failed and why provides value to the research community. Negative results that prevent others from pursuing unproductive paths constitute legitimate scientific contributions. Conversely, successful validation with concrete metrics would provide empirical support for the architectural pattern and encourage adoption in similar contexts.

=== Threats to Validity

Our analysis has several limitations that constrain the generalizability of conclusions and require explicit acknowledgment.

==== Construct Validity

*Measurement operationalization:* The success criteria defined above operationalize abstract concepts like "complexity" and "developer experience" through specific metrics. However, these metrics may not fully capture the underlying constructs. Lines of code, for example, correlate with but do not perfectly measure cognitive complexity. Alternative metrics (Halstead complexity, code churn, bug density) might yield different conclusions. Our choice of metrics reflects pragmatic measurability but introduces construct validity threats.

*Evaluation context:* Developer studies and usability assessments will necessarily occur in specific contexts—particular workflows, user populations, and deployment scenarios. Results may not generalize across all potential ChRIS use cases. Medical imaging workflows have specific characteristics (long-running computations, complex data provenance, regulatory constraints) that may not represent other domains.

==== Internal Validity

*Pre-implementation analysis:* This paper presents architectural analysis and theoretical arguments before implementation and empirical evaluation. Claims about IAS benefits are currently hypothetical, supported by reasoning from established principles but not yet validated through measurement. Implementation may reveal unforeseen challenges that undermine predicted advantages.

*Selection bias:* The three architectural alternatives analyzed (status quo, embedded, external IAS) represent our conceptualization of the solution space. We may have overlooked viable alternatives outside this framing. For example, hybrid approaches, alternative orchestration patterns, or fundamentally different architectural styles might offer superior trade-offs. Our analysis is constrained by the alternatives we considered.

*Confounding factors:* If IAS deployment coincides with other system changes—infrastructure upgrades, team growth, process improvements—attributing outcomes specifically to the IAS architecture becomes difficult. Isolating the IAS effect from confounding variables will require careful experimental design.

==== External Validity

*Single case study:* ChRIS represents a single platform in a specific domain (medical imaging) with particular requirements (federation, provenance tracking, regulatory compliance). Generalization to other scientific computing domains, enterprise systems, or commercial applications requires additional validation. The pattern may be domain-specific rather than broadly applicable.

*Organizational context:* Our analysis is shaped by constraints specific to the ChRIS project: an existing Collection+JSON deployment, a small development team, limited resources for major rewrites, and research group dynamics. Other organizations with different constraints—larger teams, greater risk tolerance, different technical debt—might reasonably reach different conclusions about optimal architecture.

*Technology evolution:* The architectural landscape continues to evolve. Emerging technologies—serverless computing, edge computing, novel API paradigms—may alter the cost-benefit calculus. Conclusions valid in 2025 may not hold in 2030 as infrastructure capabilities and developer expectations shift.

*Team expertise:* Our team has deep expertise in ChRIS architecture, Collection+JSON semantics, and medical imaging workflows. This expertise enables sophisticated architectural reasoning but may also introduce bias toward solutions that leverage existing knowledge. Teams with different expertise profiles might favor alternative approaches.

==== Reliability

*Replication challenges:* ChRIS is a complex, domain-specific system. Replicating our analysis in other contexts requires substantial effort and domain knowledge. The architectural patterns we identify may be sound, but validating their applicability elsewhere requires independent implementations and evaluations.

*Measurement consistency:* Longitudinal studies tracking API evolution and developer productivity require consistent measurement over extended periods. Team composition changes, tool evolution, and shifting requirements may introduce measurement inconsistency that threatens reliability.

==== Mitigation Strategies

We will address these threats through several strategies:

*Triangulation:* Use multiple measurement approaches—quantitative metrics, qualitative interviews, observational studies—to assess outcomes from different perspectives.

*Comparative baselines:* Measure current system characteristics (LOC, latency, developer time) before IAS implementation to enable before-after comparison.

*External review:* Engage external experts unfamiliar with ChRIS to review the architecture and challenge assumptions, reducing team-specific biases.

*Incremental validation:* Implement and evaluate IAS incrementally, validating assumptions at each stage rather than committing fully before gathering evidence.

*Transparent reporting:* Document both successes and failures, unexpected challenges, and deviations from predictions to enable community learning regardless of outcome.

Despite these limitations, the architectural analysis presented provides value even with acknowledged threats to validity. The systematic comparison of alternatives, identification of trade-offs, and articulation of validation criteria establish a framework for rigorous evaluation once implementation proceeds. These threats to validity should inform interpretation of results but do not invalidate the analytical approach.

=== Synthesis

The comparative analysis across multiple dimensions consistently favors the external IAS architecture. While it introduces operational complexity through additional service boundaries, it delivers compensating benefits: architectural purity through separation of concerns, evolutionary velocity through independent service evolution, ecosystem enablement through shared orchestration infrastructure, and future readiness for agentic interaction patterns. The trade-off—accepting operational overhead for architectural clarity and evolutionary capacity—aligns with established principles of software engineering for long-lived, evolving systems [23][38].

The broader insight concerns the incompleteness of pure hypermedia architectures. HATEOAS-driven designs provide valuable properties—discoverability, extensibility, semantic richness—but lack the procedural complement that practical systems require. The IAS completes this architecture by adding intent interpretation without compromising the declarative foundation. This pattern has applicability far beyond ChRIS, suggesting a general solution to the tension between semantic precision and operational accessibility in distributed systems.

For the ChRIS ecosystem specifically, the IAS enables multiple desirable outcomes: revival of client development through shared orchestration, UI liberation through concern separation, research accessibility through domain-appropriate abstractions, and positioning for agentic computing through intent-driven interfaces. These benefits compound over time as the system evolves and the user community diversifies.

The path forward is clear. While the external IAS introduces implementation challenges—intent governance, versioning complexity, operational overhead—these are tractable engineering problems amenable to established solutions. The architectural benefits substantially outweigh the costs. The alternative pathways—status quo maintenance or embedding orchestration in CUBE—offer marginal improvements at best while perpetuating fundamental structural problems. The external IAS represents the optimal balance for sustaining ChRIS evolution while positioning the platform for future developments in scientific computing and AI-augmented research workflows.

