== Introduction

=== Background

The ChRIS system, at its most fundamental philosophical core, explores the idea of providing general-purpose compute and data services beyond the traditional constraints of single-host or desktop computing. Conceptually, ChRIS investigates what a truly distributed, federated "uber-computer" might look like, one that spans networks and even confederations of institutions. It reimagines computing not as a local activity but as a globally composable substrate where applications, users, and data coexist within a shared operational grammar.

While ChRIS has found its initial niche in medical and radiological imaging, this should not obscure its broader aspiration. ChRIS is not merely a radiological image-processing platform; it is a general-purpose environment for computation and data orchestration. The same framework could support workflows in physical oceanography, climate modeling, or any other domain that depends on distributed, provenance-aware computation. In all these settings, ChRIS serves as the platform for applications, providing a consistent mechanism to describe, launch, and observe computational workflows independent of local infrastructure.

At its core, the backend component CUBE models and describes entities and the relationships between them: users, plugins (applications), data, and compute environments. It defines the vocabulary of computation, the nouns, verbs, and relations from which application semantics are composed. Its adoption of the Collection+JSON (Cj) hypermedia format followed directly from this logic. Cj was introduced in 2011 by Mike Amundsen as a hypermedia media type for JSON APIs, providing a consistent way to represent collections, items, and links while maintaining a self-describing structure [1]. The design was well suited to CUBE’s ambition to describe entities and relationships rather than hard-coded operations.

During the early years of ChRIS development, this choice proved prescient. The core resource types—feeds, plugins, files, and users—were well understood early on, and the model could evolve simply by adding or extending relationships without breaking existing clients. CUBE’s declarative foundation gave developers stability in a rapidly changing research environment where workflows were fluid and new domains could be added incrementally. The system’s flexibility came from its ability to describe what exists rather than what to do, a distinction central to its durability.

Over time, however, Collection+JSON and similar hypermedia-first paradigms fell out of favor in broader software practice. Developers came to prefer simpler, task-driven approaches such as OpenAPI (formerly Swagger), GraphQL, and gRPC, which emphasize explicit contracts, code generation, and procedural clarity [2–4]. Hypermedia approaches, by contrast, required clients to interpret a graph of relationships and links, which introduced cognitive overhead and made static tooling difficult. Empirical studies have repeatedly shown that few public APIs implement the hypermedia constraint at all. Bülthoff and Maleshkova found that only a small fraction of analyzed Web APIs followed HATEOAS [5], while Bogner et al. later confirmed that most APIs remain below REST maturity level 3 [6]. Practitioner analyses and community commentary echo this trend: despite its conceptual soundness, hypermedia has seen minimal real-world uptake [7–9]. Even Fielding’s own dissertation, which first defined HATEOAS as central to REST [10], anticipated the trade-off between conceptual rigor and implementation simplicity—a tension that ultimately led to hypermedia’s marginalization.

This decline reflects a deeper tension between declarative and procedural expectations. In practice, hypermedia systems lacked an intermediate layer that could interpret intent and perform orchestration automatically. Without such a layer, developers wrote custom orchestration logic per client, undermining the universality hypermedia was meant to provide. The result was practical stagnation: powerful in concept but cumbersome in application.

This historical trajectory is directly relevant to the argument here. The absence of an intent interpretation layer is precisely what has limited both hypermedia adoption in general and CUBE’s evolution in particular. Ironically, the renewed interest in agentic and LLM-driven systems now exposes the same need again. Modern agents require structured, discoverable APIs but also a way to translate natural-language goals into procedural actions. CUBE provides the first requirement; an Intent–Action Service (IAS) provides the second. Together, they realize the unfulfilled potential of hypermedia systems as self-describing yet operationally capable architectures.

=== Problem Context

Within the ChRIS ecosystem, the consequences of this architectural gap have become increasingly evident. Each client built on CUBE must understand its declarative semantics in order to perform any meaningful action. For even simple tasks—such as launching a plugin, linking data, or creating a feed—the client must traverse the CUBE graph, interpret link relationships, and manually orchestrate multiple dependent calls. This complexity has discouraged external client development and led to duplication of effort across implementations.

Every client, regardless of language or framework, has been forced to build its own mapping layer between user intention and CUBE’s primitives. Early Python and JavaScript SDKs implemented custom abstractions to simplify plugin execution, but each did so independently, re-creating similar logic. The cumulative effect has been fragmentation and maintenance fatigue. Minor changes to CUBE’s internal representation often cascade into multiple client libraries, each of which must be updated in parallel.

This dynamic illustrates a well-documented pattern in large software systems. As Lehman’s Laws of Software Evolution describe, complexity in an evolving system tends to increase unless explicit effort is made to reduce it [11]. Each independent layer of orchestration added by clients introduces new coupling and informational redundancy. Over time, such drift produces what Kruchten et al. define as architectural technical debt [12]: localized design decisions that collectively hinder adaptability. As procedural concerns seep into declarative layers, Brooks’s “No Silver Bullet” principle resurfaces—the essential complexity of the system increases faster than its capacity for change [13].

The symptoms within ChRIS align with these observations. Client diversity has diminished as development cost has risen, leaving the ChRIS-UI as the only fully functional client. To remain viable, it has absorbed orchestration logic that properly belongs elsewhere. Presentation and business logic are now interwoven: user actions directly drive sequences of CUBE calls that instantiate feeds, connect plugins, and track data provenance. This interleaving of concerns exemplifies the loss of modular separation that Carzaniga et al. identify as the precursor to architectural stagnation [14]. Even minor interface updates require modifying code that was never meant to handle orchestration, resulting in brittle, high-maintenance software.

In effect, the absence of an intent interpretation layer has transformed CUBE from a general declarative substrate into a platform usable only through one privileged client. This defeats its original purpose as a general computing language. The current state is thus one of both technical and conceptual stagnation: the model is sound, but its accessibility has collapsed. A systematic solution—one that restores separation between declarative structure and procedural behavior—is required.

An obvious response might be to discard Collection+JSON entirely and replace it with a more conventional API model such as OpenAPI or GraphQL. This proposal is not without logic: it would immediately simplify client construction and align ChRIS with dominant industry conventions. However, it is also likely short sighted. Replacing Cj would mean discarding the very property that makes CUBE uniquely extensible—its ability to represent entities and relationships independently of specific procedures. The entire ChRIS ecosystem, from persistent storage to plugin orchestration, depends on these self-describing semantics. Transitioning away from Cj would require massive re-engineering across all components, effectively redefining how the system represents itself. More importantly, it would collapse the philosophical distinction that underpins ChRIS: the idea that computation can be described, not merely executed.

Furthermore, introducing an Intent–Action Service represents not a departure from Cj, but its logical completion. The IAS provides clients with the procedural clarity and modern interface ergonomics typical of OpenAPI or GraphQL systems, enabling rapid and accessible development. Yet beneath that layer, CUBE's Cj-based semantic model remains intact, providing a rigorously structured, general-purpose representation of entities and relationships. This combination delivers the best of both worlds: a contemporary developer experience grounded on a durable, extensible foundation ideally suited to the long-term goal of generalized, distributed computing.

=== Contributions and Research Approach

This paper makes two primary contributions:

1. **Problem Characterization**: We identify and characterize the intent-orchestration impedance mismatch in hypermedia API systems, demonstrating how the absence of a procedural interpretation layer has limited both HATEOAS adoption generally and CUBE's evolution specifically (Section 2.1).

2. **Architectural Proposal**: We propose the Intent-Action Service (IAS) pattern as a solution and analyze three alternative architectural approaches using ChRIS as a concrete case study (Sections 2.2–2.4, 3).

We present this work as a *research agenda* rather than a completed solution. The IAS architecture appears promising based on systematic architectural analysis, but several empirical questions remain unanswered:

*RQ1: Complexity Reduction* — Does IAS reduce client-side complexity compared to direct hypermedia API usage? We hypothesize that intent-level APIs will decrease lines of code and cognitive complexity metrics for common operations.

*RQ2: Developer Experience* — Does the dual-API approach improve developer experience and productivity? We propose to measure this through developer studies, API usability surveys, and time-to-implementation metrics for representative tasks.

*RQ3: Performance Impact* — What is the performance overhead of the additional orchestration layer? We will benchmark latency and throughput to quantify the cost of introducing IAS between clients and CUBE.

*RQ4: Independent Evolution* — Can IAS intents evolve independently of underlying CUBE resources without breaking clients? A longitudinal study tracking API changes and client impact will test this architectural claim.

*RQ5: Generalizability* — Does this pattern extend beyond medical imaging to other orchestration-heavy domains? Case studies in related scientific computing contexts will evaluate broader applicability.

We propose to validate these questions incrementally by implementing IAS for ChRIS and measuring outcomes against the status quo. This paper documents the architectural analysis and theoretical foundation; future work will report empirical results from deployment and evaluation.

The sections that follow examine this proposal. First, three architectural pathways are outlined: maintaining the current system (the Null Path), embedding procedural intent within CUBE itself (the Embedded Path), and introducing an independent Intent–Action Service (IAS) that interprets and executes high-level operations. The discussion then evaluates these alternatives in terms of scalability, maintainability, and their implications for LLM-driven agentic interaction. The paper ultimately argues that the externalized model—the IAS—offers the most sustainable balance between expressive generality and operational accessibility, preserving CUBE’s original design philosophy while enabling a new era of intelligent orchestration.

=== References

1. Amundsen M. *Collection+JSON - Document Format.* July 2011. Available: http://amundsen.com/media-types/collection/format/
2. Sturgeon P. *JSON API, OpenAPI and JSON Schema Working in Harmony.* APIs You Won't Hate blog, September 2018. Available: https://apisyouwonthate.com/blog/json-api-openapi-and-json-schema/
3. GraphQL Foundation. *GraphQL Specification.* October 2021. Available: https://spec.graphql.org/October2021/
4. gRPC Authors. *gRPC: A High Performance, Open Source Universal RPC Framework.* Available: https://grpc.io/docs/
5. Bülthoff F., Maleshkova M. *RESTful or RESTless – Current State of Today's Top Web APIs.* In: Proc. European Semantic Web Conference (ESWC), CEUR Workshop Proceedings, Vol. 1165, pp. 42–51, 2014.
6. Bogner J., Kotstein S., Pfaff T. *Do RESTful API Design Rules Have an Impact on the Understandability of Web APIs?* Empirical Software Engineering, vol. 28, no. 6, article 132, November 2023. DOI: 10.1007/s10664-023-10367-y
7. Nordic APIs. *Unraveling the Mystery: Understanding HATEOAS.* January 8, 2024. Available: https://nordicapis.com/unraveling-the-mystery-understanding-hateoas/
8. Reiser A. *Why HATEOAS Is Useless and What That Means for REST.* Medium, February 27, 2018. Available: https://medium.com/@andreasreiser94/why-hateoas-is-useless-and-what-that-means-for-rest-a65194471bc8
9. Devōt. *Why Hypermedia Is Still a Plausible Option.* Devot.team blog, 2024. Available: https://devot.team/blog/hateoas
10. Fielding R.T. *Architectural Styles and the Design of Network-based Software Architectures.* PhD Dissertation, University of California, Irvine, 2000. Available: https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm
11. Lehman M.M. *Programs, Life Cycles, and Laws of Software Evolution.* Proceedings of the IEEE, vol. 68, no. 9, pp. 1060–1076, September 1980. DOI: 10.1109/PROC.1980.11805
12. Kruchten P., Nord R.L., Ozkaya I. *Technical Debt: From Metaphor to Theory and Practice.* IEEE Software, vol. 29, no. 6, pp. 18–21, November/December 2012. DOI: 10.1109/MS.2012.167
13. Brooks F.P. Jr. *No Silver Bullet: Essence and Accidents of Software Engineering.* Computer, vol. 20, no. 4, pp. 10–19, April 1987. DOI: 10.1109/MC.1987.1663532
14. Parnas D.L. *On the Criteria to Be Used in Decomposing Systems into Modules.* Communications of the ACM, vol. 15, no. 12, pp. 1053–1058, December 1972. DOI: 10.1145/361598.361623

